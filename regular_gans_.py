# -*- coding: utf-8 -*-
"""regular GANs .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oZ2Z2eDZPOJlYpuGokNX8CZ1f3qUNJX8
"""

# Commented out IPython magic to ensure Python compatibility.
import torch
import torch.nn as nn
import torch.optim as optim
import torchvision
import torchvision.transforms as transforms
from torch.utils.data import DataLoader
import matplotlib.pyplot as plt
import numpy as np

# Generator network for regular GAN
class RegularGANGenerator(nn.Module):
    def __init__(self, latent_dim, img_shape):
        super(RegularGANGenerator, self).__init__()

        self.model = nn.Sequential(
            nn.Linear(latent_dim, 128),
            nn.LeakyReLU(0.2, inplace=True),
            nn.Linear(128, np.prod(img_shape)),
            nn.Tanh()
        )

    def forward(self, z):
        img = self.model(z)
        img = img.view(img.size(0), *img_shape)
        return img

# Discriminator network for regular GAN
class RegularGANDiscriminator(nn.Module):
    def __init__(self, img_shape):
        super(RegularGANDiscriminator, self).__init__()

        self.model = nn.Sequential(
            nn.Linear(np.prod(img_shape), 128),
            nn.LeakyReLU(0.2, inplace=True),
            nn.Linear(128, 1),
            nn.Sigmoid()
        )

    def forward(self, img):
        img_flat = img.view(img.size(0), -1)
        validity = self.model(img_flat)
        return validity

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# Set parameters for regular GAN
latent_dim = 100
img_shape = (1, 28, 28)  # Image shape for MNIST
n_epochs = 500
lr = 0.0002
batch_size = 64

# Load dataset
transform = transforms.Compose([
    transforms.ToTensor(),
    transforms.Normalize((0.5,), (0.5,))
])

train_dataset = torchvision.datasets.MNIST(root='./data', train=True, transform=transform, download=True)
train_loader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True)

# Initialize generator and discriminator for regular GAN
regular_gan_generator = RegularGANGenerator(latent_dim, img_shape).to(device)
regular_gan_discriminator = RegularGANDiscriminator(img_shape).to(device)

# Loss function for regular GAN
adversarial_loss = nn.BCELoss()

# Optimizers for regular GAN
optimizer_G = optim.Adam(regular_gan_generator.parameters(), lr=lr)
optimizer_D = optim.Adam(regular_gan_discriminator.parameters(), lr=lr)

# Training loop for regular GAN
for epoch in range(n_epochs):
    for i, (imgs, _) in enumerate(train_loader):
        # Move data to device
        imgs = imgs.to(device)

        # Adversarial ground truths
        valid = torch.ones(imgs.size(0), 1, device=device)
        fake = torch.zeros(imgs.size(0), 1, device=device)

        # -----------------
        # Train Generator
        # -----------------
        optimizer_G.zero_grad()

        # Generate noise
        z = torch.randn(imgs.size(0), latent_dim, device=device)

        # Generate a batch of images
        gen_imgs = regular_gan_generator(z)

        # Loss measures generator's ability to fool the discriminator
        validity = regular_gan_discriminator(gen_imgs)
        g_loss = adversarial_loss(validity, valid)

        g_loss.backward()
        optimizer_G.step()

        # ---------------------
        # Train Discriminator
        # ---------------------
        optimizer_D.zero_grad()

        # Measure discriminator's ability to classify real from generated samples
        real_validity = regular_gan_discriminator(imgs)
        d_real_loss = adversarial_loss(real_validity, valid)

        # Measure discriminator's ability to classify fake samples
        fake_validity = regular_gan_discriminator(gen_imgs.detach())
        d_fake_loss = adversarial_loss(fake_validity, fake)

        # Total discriminator loss
        d_loss = 0.5 * (d_real_loss + d_fake_loss)

        d_loss.backward()
        optimizer_D.step()

        # Print progress
        if i % 100 == 0:
            print(
                "[Epoch %d/%d] [Batch %d/%d] [D loss: %.4f] [G loss: %.4f]"
#                 % (epoch, n_epochs, i, len(train_loader), d_loss.item(), g_loss.item())
            )

    # Output generated images
    if epoch % 50 == 0:
        with torch.no_grad():
            z = torch.randn(10, latent_dim, device=device)
            gen_imgs = regular_gan_generator(z).cpu().numpy()

        fig, axs = plt.subplots(1, 10, figsize=(10, 1))
        for i in range(10):
            axs[i].imshow(gen_imgs[i][0], cmap='gray')
            axs[i].axis('off')
        plt.show()

